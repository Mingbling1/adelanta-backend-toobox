name: Build, Push to ECR, Deploy

on:
    push:
        branches: [main]

jobs:
    build_and_push:
        name: Build and Push to ECR
        runs-on: ubuntu-latest
        steps:
            - name: Checkout the repository
              uses: actions/checkout@v4

            - name: Configure AWS credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ secrets.AWS_REGION }}

            - name: Login to Amazon ECR
              id: login-ecr
              uses: aws-actions/amazon-ecr-login@v2

            - name: Build and push Docker image
              uses: docker/build-push-action@v5
              with:
                  context: .
                  file: ./Dockerfile
                  push: true
                  tags: ${{ steps.login-ecr.outputs.registry }}/${{ secrets.ECR_REPOSITORY_NAME }}:latest

            # ğŸ†• NUEVA ETAPA: Limpiar imÃ¡genes antiguas
            - name: Clean old ECR images
              run: |
                  echo "ğŸ§¹ Limpiando imÃ¡genes antiguas de ECR..."

                  # Obtener imÃ¡genes ordenadas por fecha (mÃ¡s recientes primero)
                  images_to_delete=$(aws ecr describe-images \
                      --repository-name ${{ secrets.ECR_REPOSITORY_NAME }} \
                      --region ${{ secrets.AWS_REGION }} \
                      --query "reverse(sort_by(imageDetails, &imagePushedAt))[2:].imageDigest" \
                      --output text)

                  if [ -n "$images_to_delete" ]; then
                      echo "Eliminando imÃ¡genes antiguas..."
                      for digest in $images_to_delete; do
                          echo "Eliminando: $digest"
                          aws ecr batch-delete-image \
                              --repository-name ${{ secrets.ECR_REPOSITORY_NAME }} \
                              --region ${{ secrets.AWS_REGION }} \
                              --image-ids imageDigest=$digest || echo "Error eliminando $digest"
                      done
                      echo "âœ… Limpieza completada"
                  else
                      echo "âœ… No hay imÃ¡genes que eliminar"
                  fi

                  # Mostrar estado final
                  echo "ğŸ“Š ImÃ¡genes restantes:"
                  aws ecr describe-images \
                      --repository-name ${{ secrets.ECR_REPOSITORY_NAME }} \
                      --region ${{ secrets.AWS_REGION }} \
                      --query 'imageDetails[*].[imageTags[0],imagePushedAt,imageSizeInBytes]' \
                      --output table
    deploy:
        name: Deploy to EC2
        runs-on: self-hosted # Usa el runner en tu EC2
        needs: [build_and_push]
        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Deploy application
              run: |
                  # Autenticarse con ECR desde la instancia EC2
                  aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.ECR_REPOSITORY_URI }}

                  # Copiar archivos y configurar
                  mkdir -p ~/app/templates ~/app/nginx
                  cp -r templates/* ~/app/templates/ || true
                  cp -r nginx/* ~/app/nginx/ || true
                  cp docker-compose.yml ~/app/ || true
                  cp init-letsencrypt.sh ~/app/ || true
                  chmod -R 755 ~/app/templates
                  chmod 755 ~/app/init-letsencrypt.sh || true

                  # Ir al directorio de la aplicaciÃ³n
                  cd ~/app

                  # ğŸ§¹ LIMPIEZA AGRESIVA ANTES DEL DEPLOY
                  echo "ğŸ§¹ Iniciando limpieza completa del sistema Docker..."

                  # Detener todos los contenedores primero
                  echo "ğŸ›‘ Deteniendo contenedores actuales..."
                  docker-compose down --remove-orphans || true
                  docker stop $(docker ps -aq) 2>/dev/null || true

                  # Eliminar contenedores parados
                  echo "ğŸ—‘ï¸ Eliminando contenedores parados..."
                  docker ps -a -q | xargs -r docker rm -f || true
                  docker container prune -f || true

                  # CRÃTICO: Eliminar imÃ¡genes dangling (liberarÃ¡ ~16GB)
                  echo "ğŸ—‘ï¸ Eliminando imÃ¡genes <none> (dangling)..."
                  docker image prune -f

                  # Eliminar imÃ¡genes no utilizadas (mantener solo las necesarias)
                  echo "ğŸ—‘ï¸ Eliminando imÃ¡genes no utilizadas..."
                  docker image prune -a -f --filter "until=24h" || true

                  # Limpiar volÃºmenes no utilizados
                  echo "ğŸ—‘ï¸ Eliminando volÃºmenes no utilizados..."
                  docker volume prune -f || true

                  # Limpiar redes no utilizadas
                  echo "ğŸ—‘ï¸ Eliminando redes no utilizadas..."
                  docker network prune -f || true

                  # Mostrar estado despuÃ©s de limpieza
                  echo "ğŸ“Š Estado despuÃ©s de limpieza inicial:"
                  docker system df
                  df -h /

                  # Descargar nuevas imÃ¡genes
                  echo "â¬‡ï¸ Descargando imÃ¡genes actualizadas..."
                  export ECR_REPOSITORY_URI=${{ secrets.ECR_REPOSITORY_URI }}
                  docker-compose pull

                  # Levantar servicios
                  echo "ğŸš€ Iniciando servicios..."
                  docker-compose up -d

                  # Esperar que los servicios estÃ©n listos
                  echo "â³ Esperando que los servicios estÃ©n listos..."
                  sleep 15

                  # Verificar que los servicios estÃ¡n corriendo
                  echo "ğŸ” Verificando servicios..."
                  docker-compose ps

                  # LIMPIEZA FINAL despuÃ©s del deploy
                  echo "ğŸ§¹ Limpieza final post-deploy..."
                  docker image prune -f

                  # Mostrar solo las imÃ¡genes que quedaron
                  echo "ğŸ“¦ ImÃ¡genes restantes despuÃ©s del deploy:"
                  docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}"

                  # Configurar SSL
                  echo "ğŸ” Configurando SSL..."

                  # Verificar existencia del script
                  if [ -f "./init-letsencrypt.sh" ]; then
                      echo "âœ… Script SSL encontrado"
                      chmod +x ./init-letsencrypt.sh
                      
                      # Ejecutar configuraciÃ³n SSL
                      echo "ğŸ” Ejecutando configuraciÃ³n SSL..."
                      ./init-letsencrypt.sh || {
                          echo "âš ï¸ Primer intento SSL fallÃ³, intentando con sudo..."
                          sudo ./init-letsencrypt.sh || echo "âš ï¸ ConfiguraciÃ³n SSL fallÃ³, pero continuando..."
                      }
                  else
                      echo "âš ï¸ Script SSL no encontrado, omitiendo configuraciÃ³n SSL"
                  fi

                  # MONITOREO Y DIAGNÃ“STICO FINAL
                  echo "ğŸ“Š DiagnÃ³stico final del sistema:"
                  echo "=================================="

                  # Espacio en disco
                  echo "ğŸ’¾ Espacio en disco:"
                  df -h /

                  # Estado de Docker
                  echo "ğŸ³ Estado de Docker:"
                  docker system df

                  # Servicios corriendo
                  echo "ğŸ”„ Servicios corriendo:"
                  docker-compose ps

                  # Logs recientes para verificar que todo funciona
                  echo "ğŸ“‹ Logs recientes del servicio web:"
                  docker logs web --tail 10 || true

                  # Verificar conectividad
                  echo "ğŸŒ Verificando conectividad del servicio:"
                  curl -s -o /dev/null -w "CÃ³digo HTTP: %{http_code}\n" http://localhost:8000/health || echo "âŒ Servicio no responde"

                  # Verificar memoria disponible
                  echo "ğŸ§  Memoria del sistema:"
                  free -h

                  # ALERTA si el disco sigue muy lleno
                  DISK_USAGE=$(df / | grep -vE '^Filesystem' | awk '{print $5}' | sed 's/%//g')
                  if [ $DISK_USAGE -gt 85 ]; then
                      echo "ğŸš¨ ALERTA: Disco al ${DISK_USAGE}% despuÃ©s de limpieza"
                      echo "ğŸ§¹ Ejecutando limpieza adicional de emergencia..."
                      
                      # Limpieza adicional de emergencia
                      docker system prune -a --volumes --force
                      
                      # Limpiar logs del sistema
                      sudo journalctl --vacuum-size=50M || true
                      sudo find /var/log -name "*.log" -type f -size +10M -exec truncate -s 0 {} \; || true
                      
                      echo "ğŸ“Š Estado despuÃ©s de limpieza de emergencia:"
                      df -h /
                  else
                      echo "âœ… Espacio en disco OK: ${DISK_USAGE}%"
                  fi

                  echo "âœ… Despliegue completado exitosamente"
                  echo "ğŸ‰ Sistema optimizado y funcionando"

    test:
        name: Test deployment
        runs-on: self-hosted
        needs: [deploy]
        steps:
            - name: Run tests
              run: |
                  cd ~/app

                  # âœ… Test bÃ¡sico de conectividad
                  echo "ğŸŒ Verificando conectividad del servicio web..."
                  HEALTH_ENDPOINT="http://localhost:8000/"
                  response=$(curl -Ls -o /dev/null -w "%{http_code}" -X GET "$HEALTH_ENDPOINT")
                  echo "CÃ³digo de respuesta del health check: $response"

                  if [ "$response" -eq 200 ]; then
                      echo "âœ… Servicio web funcionando correctamente"
                  else
                      echo "âš ï¸ Servicio web responde con cÃ³digo: $response"
                  fi

                  echo "Esperando 10 segundos para estabilizaciÃ³n..."
                  sleep 10

                  # âœ… Verificar nuevos endpoints de Celery
                  echo "ğŸ® Verificando endpoints de Celery Tasks..."
                  CELERY_ENDPOINT="http://localhost:8000/api/toolbox/tasks/available"
                  celery_response=$(curl -Ls -o /dev/null -w "%{http_code}" -X GET "$CELERY_ENDPOINT")
                  echo "CÃ³digo de respuesta de Celery Tasks: $celery_response"

                  if [ "$celery_response" -eq 200 ]; then
                      echo "âœ… Celery Tasks API funcionando correctamente"
                  else
                      echo "âš ï¸ Celery Tasks API responde con cÃ³digo: $celery_response"
                      echo "Continuando de todos modos..."
                  fi

                  # âœ… Verificar que los workers de Celery estÃ©n funcionando
                  echo "ğŸ”„ Verificando workers de Celery..."
                  if docker ps | grep -q celery_worker; then
                      echo "âœ… Celery worker container estÃ¡ corriendo"
                      docker logs celery_worker --tail 10 || echo "No se pudieron obtener logs del worker"
                  else
                      echo "âš ï¸ Celery worker container no encontrado"
                  fi

                  if docker ps | grep -q celery_beat; then
                      echo "âœ… Celery beat container estÃ¡ corriendo"  
                      docker logs celery_beat --tail 5 || echo "No se pudieron obtener logs del beat"
                  else
                      echo "âš ï¸ Celery beat container no encontrado"
                  fi
