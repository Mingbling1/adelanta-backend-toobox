name: Build, Push to ECR, Deploy

on:
    push:
        branches: [main]

jobs:
    build_and_push:
        name: Build and Push to ECR
        runs-on: ubuntu-latest
        steps:
            - name: Checkout the repository
              uses: actions/checkout@v4

            - name: Configure AWS credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ secrets.AWS_REGION }}

            - name: Login to Amazon ECR
              id: login-ecr
              uses: aws-actions/amazon-ecr-login@v2

            - name: Build and push Docker image
              uses: docker/build-push-action@v5
              with:
                  context: .
                  file: ./Dockerfile
                  push: true
                  tags: ${{ steps.login-ecr.outputs.registry }}/${{ secrets.ECR_REPOSITORY_NAME }}:latest

            # üÜï NUEVA ETAPA: Limpiar im√°genes antiguas
            - name: Clean old ECR images
              run: |
                  echo "üßπ Limpiando im√°genes antiguas de ECR..."

                  # Obtener im√°genes ordenadas por fecha (m√°s recientes primero)
                  images_to_delete=$(aws ecr describe-images \
                      --repository-name ${{ secrets.ECR_REPOSITORY_NAME }} \
                      --region ${{ secrets.AWS_REGION }} \
                      --query "reverse(sort_by(imageDetails, &imagePushedAt))[2:].imageDigest" \
                      --output text)

                  if [ -n "$images_to_delete" ]; then
                      echo "Eliminando im√°genes antiguas..."
                      for digest in $images_to_delete; do
                          echo "Eliminando: $digest"
                          aws ecr batch-delete-image \
                              --repository-name ${{ secrets.ECR_REPOSITORY_NAME }} \
                              --region ${{ secrets.AWS_REGION }} \
                              --image-ids imageDigest=$digest || echo "Error eliminando $digest"
                      done
                      echo "‚úÖ Limpieza completada"
                  else
                      echo "‚úÖ No hay im√°genes que eliminar"
                  fi

                  # Mostrar estado final
                  echo "üìä Im√°genes restantes:"
                  aws ecr describe-images \
                      --repository-name ${{ secrets.ECR_REPOSITORY_NAME }} \
                      --region ${{ secrets.AWS_REGION }} \
                      --query 'imageDetails[*].[imageTags[0],imagePushedAt,imageSizeInBytes]' \
                      --output table
    deploy:
        name: Deploy to EC2
        runs-on: self-hosted # Usa el runner en tu EC2
        needs: [build_and_push]
        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Deploy application
              run: |
                  # Autenticarse con ECR desde la instancia EC2
                  aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.ECR_REPOSITORY_URI }}

                  # Copiar archivos y configurar
                  mkdir -p ~/app/templates ~/app/nginx
                  cp -r templates/* ~/app/templates/ || true
                  cp -r nginx/* ~/app/nginx/ || true
                  cp docker-compose.yml ~/app/ || true
                  cp init-letsencrypt.sh ~/app/ || true
                  chmod -R 755 ~/app/templates
                  chmod 755 ~/app/init-letsencrypt.sh || true

                  # Ir al directorio de la aplicaci√≥n
                  cd ~/app

                  # üßπ LIMPIEZA AGRESIVA ANTES DEL DEPLOY
                  echo "üßπ Iniciando limpieza completa del sistema Docker..."
                  
                  # Detener todos los contenedores primero
                  echo "üõë Deteniendo contenedores actuales..."
                  docker-compose down --remove-orphans || true
                  docker stop $(docker ps -aq) 2>/dev/null || true
                  
                  # Eliminar contenedores parados
                  echo "üóëÔ∏è Eliminando contenedores parados..."
                  docker ps -a -q | xargs -r docker rm -f || true
                  docker container prune -f || true
                  
                  # CR√çTICO: Eliminar im√°genes dangling (liberar√° ~16GB)
                  echo "üóëÔ∏è Eliminando im√°genes <none> (dangling)..."
                  docker image prune -f
                  
                  # Eliminar im√°genes no utilizadas (mantener solo las necesarias)
                  echo "üóëÔ∏è Eliminando im√°genes no utilizadas..."
                  docker image prune -a -f --filter "until=24h" || true
                  
                  # Limpiar vol√∫menes no utilizados
                  echo "üóëÔ∏è Eliminando vol√∫menes no utilizados..."
                  docker volume prune -f || true
                  
                  # Limpiar redes no utilizadas
                  echo "üóëÔ∏è Eliminando redes no utilizadas..."
                  docker network prune -f || true
                  
                  # Mostrar estado despu√©s de limpieza
                  echo "üìä Estado despu√©s de limpieza inicial:"
                  docker system df
                  df -h /

                  # Descargar nuevas im√°genes
                  echo "‚¨áÔ∏è Descargando im√°genes actualizadas..."
                  export ECR_REPOSITORY_URI=${{ secrets.ECR_REPOSITORY_URI }}
                  docker-compose pull

                  # Levantar servicios
                  echo "üöÄ Iniciando servicios..."
                  docker-compose up -d

                  # Esperar que los servicios est√©n listos
                  echo "‚è≥ Esperando que los servicios est√©n listos..."
                  sleep 15

                  # Verificar que los servicios est√°n corriendo
                  echo "üîç Verificando servicios..."
                  docker-compose ps

                  # LIMPIEZA FINAL despu√©s del deploy
                  echo "üßπ Limpieza final post-deploy..."
                  docker image prune -f
                  
                  # Mostrar solo las im√°genes que quedaron
                  echo "üì¶ Im√°genes restantes despu√©s del deploy:"
                  docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}"
                  
                  # Configurar SSL
                  echo "üîê Configurando SSL..."
                  
                  # Verificar existencia del script
                  if [ -f "./init-letsencrypt.sh" ]; then
                      echo "‚úÖ Script SSL encontrado"
                      chmod +x ./init-letsencrypt.sh
                      
                      # Ejecutar configuraci√≥n SSL
                      echo "üîê Ejecutando configuraci√≥n SSL..."
                      ./init-letsencrypt.sh || {
                          echo "‚ö†Ô∏è Primer intento SSL fall√≥, intentando con sudo..."
                          sudo ./init-letsencrypt.sh || echo "‚ö†Ô∏è Configuraci√≥n SSL fall√≥, pero continuando..."
                      }
                  else
                      echo "‚ö†Ô∏è Script SSL no encontrado, omitiendo configuraci√≥n SSL"
                  fi

                  # MONITOREO Y DIAGN√ìSTICO FINAL
                  echo "üìä Diagn√≥stico final del sistema:"
                  echo "=================================="
                  
                  # Espacio en disco
                  echo "üíæ Espacio en disco:"
                  df -h /
                  
                  # Estado de Docker
                  echo "üê≥ Estado de Docker:"
                  docker system df
                  
                  # Servicios corriendo
                  echo "üîÑ Servicios corriendo:"
                  docker-compose ps
                  
                  # Logs recientes para verificar que todo funciona
                  echo "üìã Logs recientes del servicio web:"
                  docker logs web --tail 10 || true
                  
                  # Verificar conectividad
                  echo "üåê Verificando conectividad del servicio:"
                  curl -s -o /dev/null -w "C√≥digo HTTP: %{http_code}\n" http://localhost:8000/health || echo "‚ùå Servicio no responde"
                  
                  # Verificar memoria disponible
                  echo "üß† Memoria del sistema:"
                  free -h
                  
                  # ALERTA si el disco sigue muy lleno
                  DISK_USAGE=$(df / | grep -vE '^Filesystem' | awk '{print $5}' | sed 's/%//g')
                  if [ $DISK_USAGE -gt 85 ]; then
                      echo "üö® ALERTA: Disco al ${DISK_USAGE}% despu√©s de limpieza"
                      echo "üßπ Ejecutando limpieza adicional de emergencia..."
                      
                      # Limpieza adicional de emergencia
                      docker system prune -a --volumes --force
                      
                      # Limpiar logs del sistema
                      sudo journalctl --vacuum-size=50M || true
                      sudo find /var/log -name "*.log" -type f -size +10M -exec truncate -s 0 {} \; || true
                      
                      echo "üìä Estado despu√©s de limpieza de emergencia:"
                      df -h /
                  else
                      echo "‚úÖ Espacio en disco OK: ${DISK_USAGE}%"
                  fi

                  echo "‚úÖ Despliegue completado exitosamente"
                  echo "üéâ Sistema optimizado y funcionando"

    test:
        name: Test deployment
        runs-on: self-hosted
        needs: [deploy]
        steps:
            - name: Run tests
              run: |
                  cd ~/app
                  docker exec web pytest test/cronjob/test_cronjob.py || echo "Tests ejecutados"

                  echo "Esperando 10 segundos..."
                  sleep 10

                  echo "Invocando endpoint force-check..."
                  ENDPOINT="http://localhost:8000/api/cronjob/force-check"
                  response=$(curl -Ls -o /dev/null -w "%{http_code}" -X POST "$ENDPOINT")
                  echo "C√≥digo de respuesta: $response"

                  if [ "$response" -eq 200 ]; then
                      echo "Success: Scheduler triggered to check for jobs."
                  else
                      echo "Error: HTTP status $response"
                      echo "Continua de todos modos..."
                  fi

                  echo "Verificando que el worker RQ est√© funcionando:"
                  docker logs rq_worker --tail 20
